# 高性能融合网络TCP/IP通信协议的设计与实现 #
## 摘要 ##
## 第1章 引言 ##
### 基本术语 ###
本小节介绍本文中使用的术语和缩写。

8个位的量在计算机学科被称为字节（byte），但网络相关的文献中被称为octet。我们沿用这个传统。

当涉及TCP/IP网络协议的分层时，使用基于OSI参考模型的通称Ln协议术语。如L2、L3和L4分别用来表示链路层、网络层和传输层。多数情况下，L2为以太网的同义词，L3指IPv4或IPv6，L4只UDP、TCP、ICMP。

(这里应有一张术语缩写表)

## 第2章 相关研究 ##

## 第Z章 调试  ##
本章讨论内核和内核模块的调试方法。虽然Linux项目的发起人Linus不信任调试器，认为调试器会诱导人们只着眼解决表面问题而忽视内在设计，进而影响代码健壮性[LDD3]。但是由于GNU/Linux内核是一个复杂的系统，对于大多数内核开发人员，掌握一些调试的方法是完成开发的的关键步骤，特别是遇到内核'PANIC'错误，导致系统再也无法和用户交互，从而影响排错进度。

本章着重介绍通过VMware虚拟机软件和'KGDB'调试器，对目标机的内核和动态加载的模块进行串口调试的过程。使用的主机本身即为运行着Linux操作系统的物理机器，这种情况资料匮乏，大多数文档描述两台物理地址或两台虚拟机联机调试的方法。通过试错实验，总结经验作为本章主要内容。

### 日志调试 ###
在谈论内核调试器之前，我们先了解一下内核本身提供的一种日志调试方法（函数）:printk。缜密设计出的printk可以在内核代码的任何地方（包括原子上下文）使用，向一个环形缓冲区中输入调试信息,并支持与应用层标准库中printf函数一致的格式化字符串。日志可以由dmesg命令查看。printk共有8个日志级别(0~7,数字越大，级别越低)，方便筛选开发者关注的调试信息。

printk的好处在于哪里都可以调用，简单不需要对内核做任何配置修改和环境搭建。但是，它的弊端并没有被它带来的方便所掩盖。首先，printk本身一种日志调试，而在软件工程中，日志调试通常是软件开发后期用来分析性能瓶颈的。对于一个正在开发中的内核项目，它的调试效率极低。因为在每次排查一个内核崩溃错误时，通常要在代码中插入多个printk，运用二分法多次尝试才有可能定位到错误位置。正因如此，随处插入printk影响了编码风格，为后期清理增加了工作。其次，日志缓冲区有限且易失，一旦内核发生严重错误当机，是难以查看导致内核当机时状态的。

printk作为调试手段之一，是一种静态分析程序运行流程和中间状态的方法，而我们需要一种强大的交互式调试器。交互的含义我认为，是能使我们能像使用GDB那样单步执行我们的内核程序，让我们深入分析内核每一步执行时的状态。这样的调试器有多种，本章剩余部分将会详细描述其中一种——KGDB的配置和使用。

### KGDB ###
KGDB在2.6.26-RC5内核版本是被加入内核树主分支。在这之前作为补丁出现。[http://elinux.org/Kgdb]。也就是说KGDB是新版本内核现成的功能，然而这并不意味着开发者什么都不用做就使用KGDB。内核级的调试器，采用双机调试的方式。作为本章范围内的约定，运行打开KGDB调试器的内核叫做目标内核，机器叫做目标机，也叫TARGET。运行GDB通过串口连接并调试目标机的机器我们约定为主机HOST。

#### 实验环境 ####
(这里应该形成一张表)
主机: 物理机器，Ubuntu14.04x86_64
目标机: 虚拟机(in VMware 6.0)，CentOSx86_64，KernelVer=2.6.32

注意主机和目标机处理机架构要一致（这里都是x86_64），否则HOST的gdb无法识别TARGET的内核二进制文件的格式，强行调试的话没准得整个交叉编译工具链里的gdb。

#### 构建目标机 ####

编译内核之前，通过配置将下列开关打开：

    ...
    CONFIG_MAGIC_SYSRQ=y
    ...
    CONFIG_DEBUG_INFO=y
    ...
    CONFIG_KGDB=y
    CONFIG_KGDB_SERIAL_CONSOLE=y
    ...

再将下面这个开关关闭，因为这个选项的作用是保护内核数据结构不被第三方访问或修改，而观察和修改数据正是我们调试内核时要做的——例如我们需要打断电暂停内核的执行来观察变量。

    # CONFIG_DEBUG_RODATA is not set

编译安装所用命令：

    make -j4 && make -j4 modules && sudo make modules_install \
                        && sudo make install && make -B vmlinux
                    
这串指令将编译内核和模块，然后安装内核和模块。最后一个vmlinux需要留心，主机的gdb就是从这里获得内核符号的。/boot/有同名二进制镜像，不过那是是精简压缩过，包含信息过少，不能被调试过程使用。

#### 连接主机和目标机 ####

我使用了VMware提供的虚拟串口和主机通信，完成“远程“调试。首先需要确保虚拟机处于关闭状态，再在硬件配置里为虚拟机添加Serial Port。

![](img/add-serial-port.png)

因为调试需要交互，使用第三种｀Use Socket(named pipe)｀连接方式。文件路径和名称可以自定义。核心技术是｀from server to application｀要选对。操作完成后，启动虚拟机系统，/tmp/中出现了dbg_pipe文件。

下面我们测试联通性。

    # 在主机上执行 #
    socat /tmp/dbg_pipe TCP4-LISTEN:9001　#将文件映射到一个端口
    telnet 127.0.0.1 9001

    # 在目标机上执行 #
    sudo chmod 222 /dev/ttyS1
    echo 'hello' > /dev/ttyS1
    
这时在HOST的telnet回话中会显示hello。这里的ttyS*到底是几每个机器不一样。在VMware创建虚拟机的默认过程，串口打印机占用了ttyS0。所以在默认情况下，对于新装的虚拟机，第一个手动添加串口设备文件对应ttyS1。

反过来，从HOST向TARGET传送数据：

    # 在目标机上执行 #
    sudo cat /dev/ttyS1

此时在主机上的telnet会话中敲入一些字符，这些字符将在TARGET的终端里显示。

#### 调试内核 ####
注意：执行上述操作前确认socat /tmp/dbg_pipe TCP4-LISTEN:9001在执行。

首先，修改内核参数/boot/grub/目录中的grub.cfg或是menu.lst（需要root权限）。在kernel或linux指令后追加参数：kgdboc=ttyS1,115200。有时候我们需要调试内核启动过程，需要内核等着调试器接管后再启动，这种情况下可以加kgdbwait参数。这样系统启动时，如果没有调试器接入并发送c(ontinue)命令，就停在那儿等。

进入系统后，我们需要断下内核。

    # 在目标机上执行 #
    sudo chmod 222 /proc/sysrq-trigger
    echo g > /proc/sysrq-trigger
    
这样，内核就会暂停运行，等待调试器接管、给出指令。

    # 在主机上执行 #
    gdb ./vmlinux
    ...
    (gdb) set serial baud 115200
    (gdb) target remote localhost:9001
    
vmlinux就是上面编译安装部分讲到的生成的vmlinux，我们需要把它从TARGET中拷贝到HOST上。

#### 模块调试 ####
我们知道Linux是宏内核，内核和所有模块都运行在同一地址空间，这为我们调试内核提供了便利。但是，我们还是不能直接用上面的方法调试内核模块。如果模块中提供了一个foo函数，调试者直接break foo是没法在这个函数的入口处打断点的，因为系统找不到符号。GDB是从vmlinux文件中获得符号，而模块的符号并不包含在vmlinux中（vmlinux建立时模块可能都不存在）。模块的符号都存在ko文件里，我们需要导入这个文件。

    # 在GDB中执行 #
    (gdb) add-symbol-file <your-module.ko> <address>

其中<your-module.ko>就是编译后模块文件的名称，<address>是模块代码段的加载地址。GDB就是通过这个偏移量算出每个符号在运行内核中的地址。模块加载地址这样查看：

    sudo cat /sys/module/<your-module>/sections/.text


#### 降低优化程度 ####
至此，调试环境基本搭建完成。但是由于内核编译时进行了，破坏了二进制代码和源代码对应关系。下面提供了一种降低优化程度的办法。

    # Makefile里头加这个 #
    ifeq ($(DEBUG),y)
        DEBFLAGS = -O -g -DSBULL_DEBUG
    else
        DEBFLAGS = -O2
    endif
    EXTRA_CFLAGS += $(DEBFLAGS)
    
应当我们最多可以将优化降低至O1级。完全关闭优化，会导致内核变异出错。因为内核中用到了一些优化带来的特性，如展开内联函数。
